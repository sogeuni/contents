> It is easier to port a shell than a shell script.
>
> --<cite>Larry Wall</cite>

This book deals specifically with Bash scripting on a GNU/Linux system. All the same, users of **sh** and **ksh** will find much of value here.

As it happens, many of the various shells and scripting languages seem to be converging toward the [[abs/part1/sha-bang/index#^POSIX2REF|POSIX]] 1003.2 standard. Invoking Bash with the --posix option or inserting a **set -o posix** at the head of a script causes Bash to conform very closely to this standard. Another alternative is to use a _#!/bin/sh_ [[abs/part1/sha-bang/index#^SHABANGREF|sha-bang header]] in the script, rather than _#!/bin/bash_. [^1] Note that /bin/sh is a [[basic#^LINKREF|link]] to /bin/bash in Linux and certain other flavors of UNIX, and a script invoked this way disables extended Bash functionality.

Most Bash scripts will run as-is under **ksh**, and vice-versa, since Chet Ramey has been busily porting **ksh** features to the latest versions of Bash.

On a commercial UNIX machine, scripts using GNU-specific features of standard commands may not work. This has become less of a problem in the last few years, as the GNU utilities have pretty much displaced their proprietary counterparts even on "big-iron" UNIX. [Caldera's release of the source](http://linux.oreillynet.com/pub/a/linux/2002/02/28/caldera.html) to many of the original UNIX utilities has accelerated the trend.

Bash has certain features that the traditional [[why-shell#^BASHDEF|Bourne shell]] lacks. Among these are:

- Certain extended [[options#^INVOCATIONOPTIONSREF|invocation options]]
- [[commandsub#^COMMANDSUBREF|Command substitution]] using **$( )** notation
- [[37.2. Bash, version 3#^BRACEEXPREF3|Brace expansion]]
- Certain [[Chapter 27. Arrays#^ARRAYREF|array]] operations, and [[bashver4#^ASSOCARR|associative arrays]]
- The [[testconstructs#^DBLBRACKETS|double brackets]] extended test construct
- The [[dblparens#^DBLPARENSREF|double-parentheses]] arithmetic-evaluation construct
- Certain [[string-manipulation#^STRINGMANIP|string manipulation]] operations
- [[Chapter 23. Process Substitution#^PROCESSSUBREF|Process substitution]]
- A Regular Expression [[37.2. Bash, version 3#^REGEXMATCHREF|matching operator]]
- Bash-specific [[internal#^BUILTINREF|builtins]]
- [[bashver4#^COPROCREF|Coprocesses]]

See the [[ftp://ftp.cwru.edu/pub/bash/FAQ|Bash F.A.Q.]] for a complete listing.

## 36.9.1. A Test Suite

Let us illustrate some of the incompatibilities between Bash and the classic Bourne shell. Download and install the ["Heirloom Bourne Shell"](http://freshmeat.net/projects/bournesh) and run the following script, first using Bash, then the classic _sh_.

**Example 36-23. Test Suite**

```
#!/bin/bash
# test-suite.sh
# A partial Bash compatibility test suite.
# Run this on your version of Bash, or some other shell.

default_option=FAIL         # Tests below will fail unless . . .

echo
echo -n "Testing "
sleep 1; echo -n ". "
sleep 1; echo -n ". "
sleep 1; echo ". "
echo

# Double brackets
String="Double brackets supported?"
echo -n "Double brackets test: "
if [[ "$String" = "Double brackets supported?" ]]
then
  echo "PASS"
else
  echo "FAIL"
fi


# Double brackets and regex matching
String="Regex matching supported?"
echo -n "Regex matching: "
if [[ "$String" =~ R.....matching* ]]
then
  echo "PASS"
else
  echo "FAIL"
fi


# Arrays
test_arr=$default_option     # FAIL
Array=( If supports arrays will print PASS )
test_arr=${Array[5]}
echo "Array test: $test_arr"


# Command Substitution
csub_test ()
{
  echo "PASS"
}

test_csub=$default_option    # FAIL
test_csub=$(csub_test)
echo "Command substitution test: $test_csub"

echo

#  Completing this script is an exercise for the reader.
#  Add to the above similar tests for double parentheses,
#+ brace expansion, process substitution, etc.

exit $?
```

[^1]: Or, better yet, [[system#^ENVV2REF|#!/bin/env sh]].
